/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "stm32f407xx.h"

extern uint32_t systemTimeCounter;


void delayMs(uint32_t delay)
{
	uint32_t curr = systemTimeCounter;
	while(systemTimeCounter - curr < delay)
	{	}
}



int main(void)
{
	// PWR AND SYS ENABLE
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CSR |= PWR_CSR_VOSRDY;

	SysTick_Config(16000000/1000);
	NVIC_SetPriority(SysTick_IRQn,0);
	NVIC_EnableIRQ(SysTick_IRQn);

	// switches
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;
	GPIOE->MODER &= ~((3 << GPIO_MODER_MODE7_Pos)|(3 << GPIO_MODER_MODE8_Pos));
	GPIOE->MODER &= ~((3 << GPIO_MODER_MODE9_Pos)|(3 << GPIO_MODER_MODE10_Pos));

	//LEDs
	//RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN | RCC_AHB1ENR_GPIOEEN;
	GPIOE->MODER &= ~((3 << GPIO_MODER_MODE11_Pos)|(3 << GPIO_MODER_MODE12_Pos));
	GPIOE->MODER &= ~((3 << GPIO_MODER_MODE13_Pos)|(3 << GPIO_MODER_MODE14_Pos));

	GPIOE->MODER |= ((1 << GPIO_MODER_MODE11_Pos)|(1 << GPIO_MODER_MODE12_Pos));
	GPIOE->MODER |= ((1 << GPIO_MODER_MODE13_Pos)|(1 << GPIO_MODER_MODE14_Pos));

	// USART
	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
	GPIOA->MODER &= ~((3 << GPIO_MODER_MODE2_Pos)| (3 <<GPIO_MODER_MODE3_Pos ));
	GPIOA->MODER |= (2 << GPIO_MODER_MODE2_Pos)| (2 <<GPIO_MODER_MODE3_Pos );
	GPIOA->OSPEEDR |=  GPIO_OSPEEDER_OSPEEDR2 | GPIO_OSPEEDER_OSPEEDR3;
	GPIOA->AFR[0] |= (7 << GPIO_AFRL_AFSEL2_Pos) | (7 << GPIO_AFRL_AFSEL3_Pos);

	RCC->APB1ENR |= RCC_APB1ENR_USART2EN;

	USART2->CR1 &= ~(USART_CR1_M); // 8 бит
	//USART->CR1 |= USART_CR1_OVER8;
	USART2->BRR |= 0X342; // baud rate register
	USART2->CR2 &= ~(USART_CR2_STOP); // стоп бит
	USART2->CR1 |= USART_CR1_UE; // периферия
	USART2->CR1 |= USART_CR1_TE | USART_CR1_RE; // receive transmit

	char str[] = "Eternity";

	//while(!(USART2->SR & USART_SR_RXNE));
	//str[2] = USART2->DR;
	for(int i =0; str[i];i++)
	{
		while(!(USART2->SR & USART_SR_TXE));
		USART2->DR = str[i];
	}

	uint8_t mode = 2;
	uint32_t symbol = ' ';
	uint32_t flag = 0;
	while (1)
	{

		if(mode == 1) {
			if(USART2->SR & USART_SR_RXNE) {
				symbol = USART2->DR;
				while(!(USART2->SR & USART_SR_TXE));
				USART2->DR = symbol;
			}
		}

		if(mode == 2) {
			if(USART2->SR & USART_SR_RXNE) {
				symbol = USART2->DR;
				flag = 1;
			}
			if(flag) {
				while(!(USART2->SR & USART_SR_TXE));
				USART2->DR = symbol;
			}
		}

		if(mode == 3) {
			const char *response;
			if(USART2->SR & USART_SR_RXNE) {
				symbol = USART2->DR;
				switch(symbol) {
				case 'f':
					response = "Putin";
					break;
				case 'i':
					response = "Vladimir";
					break;
				case 'o':
					response = "Vladimirovich";
					break;
				}
				for(int i =0; response[i];i++)
				{
					while(!(USART2->SR & USART_SR_TXE));
					USART2->DR = response[i];
				}
			}
		}

		if(mode == 4) {
			for(int i = 0; i <= 127; ++i) {
				while(!(USART2->SR & USART_SR_TXE));
				USART2->DR = i;
			}
		}

		delayMs(1000);

	}

}
